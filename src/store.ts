
import * as debug from 'debug';
import { v1, v4 } from 'uuid';
import { DataSnapshot, FirebaseApi, Reference } from './firebase';
import { Model, ModelClass, ModelPromise } from './model';

const log: debug.IDebugger = debug('ninjafire:store');

export class Store {
  public basePath: string = '';
  public database: FirebaseApi;

  /**
   * A pathPrefix links a 'group' key to a path in the DB. eg 'team' : '/team/123456'
   * This prefix is then prefixed to the references for the model
   */
  public pathPrefix: { [group: string]: string } = {};

  // Whether to generate UUID id's or use 'push' style id's
  // The value is the version of UUID to generate
  private _useUUID?: number;

  // Used by the store to store active records
  private _activeRecords: { [modelName: string]: { [id: string]: ModelPromise<Model> } } = {};

  /**
   * Initialize a store.
   * Optionally you can pass a 'basePath' to prefix all records in Firebase, effectively 'chroot'ing them.
   * By default id's will use the format generated by 'push()', optionally you can have UUIDv4 formatted id's
   * @param database A firebase database
   * @param options an object containing, optionally, basePath and useUUID
   */

  constructor(database: FirebaseApi, options?: { basePath?: string, useUUID?: number }) {
    this.database = database;
    if (options) {
      if (options.basePath) {
        this.basePath = options.basePath;
      }
      if (options.useUUID) {
        this._useUUID = options.useUUID;
      }
    }
  }

  public createRecord<T extends Model>(recordClass: ModelClass<T>): T {
    // The constructor will automatically assign a v4 uuid if an id was not provided
    const record: T = new recordClass(this);
    record.isValid = true;
    record.isNew = true;
    const p = Promise.resolve(record);
    const mp = Object.assign(p, { id: record.id, modelName: record.modelName });
    this.storeActiveRecord(mp);
    return record;
  }

  public findRecord<T extends Model>(recordClass: ModelClass<T>, id: string): ModelPromise<T> {
    const activeRecord = this.retrieveActiveRecord(recordClass, id);
    if (activeRecord) {
      log('found existing record from store for id: %d', id);
      return activeRecord;
    }
    log('record not found for %d going to look it up', id);
    const record: T = new recordClass(this, id);
    const mp = this._linkToFirebase(record);
    this.storeActiveRecord(mp);
    return mp;
  }

  /**
   * Get a record by class and ID without triggering a request to Firebase. If the record is already loaded
   * it will be returned, otherwise null will be returned.
   */
  public peekRecord<T extends Model>(recordClass: ModelClass<T>, id: string): T | undefined {
    log(`peeking for existing record ${id}`);
    const mp = this.retrieveActiveRecord(recordClass, id);
    if (mp) {
      let instance: T | undefined;
      // If the promise is resolved, this will do assignment immediately
      mp.then(record => instance = record as T);
      return instance;
    } else {
      return undefined;
    }
  }

  /**
   * Links a record to it's firebase reference, required when saving a newly created record, or for otherwise forcing a refresh
   * @param record The record to (re) link to firebase
   */
  public _linkToFirebase<T extends Model>(record: T): ModelPromise<T> {
    // If the record is already has an active reference then stop listening to further updates
    if (record._ref !== undefined && record._ref !== null) {
      record._ref.off();
    }

    const path: string = record._path;
    log(`looking for record at path ${path}`);
    const ref = this.database.ref(path);
    record._ref = ref;

    const p = new Promise<T>((resolve, reject) => {
      ref.on('value', (dataSnapshot: DataSnapshot | null) => {
        log(`got data for ${record.id}`);
        const result: any = dataSnapshot ? dataSnapshot.val() : null;
        if (this._activeRecords[record.modelName] !== undefined && this._activeRecords[record.modelName][record.id] !== undefined) {
          if (result !== null) {
            record.setAttributesFrom(result);
          } else {
            if (record.isDeleted) {
              log('received null data for deleted record, ignore it');
              resolve(record);
            } else {
              reject(`record not found for key ${ref.key}`);
            }
          }
          record.isValid = true;
          resolve(record);
        } else {
          log(`ignoring data received form ${record.id} that is no longer an active record`);
          resolve(record);
        }
      });
    });
    return Object.assign(p, { id: record.id, modelName: record.modelName });
  }

  /**
   * Unloads the record from the store. This will cause the record to be destroyed and freed up for garbage collection.
   * @param {Model} record
   */
  public unloadRecord(record: Model): void {
    record._willUnload();
    delete this._activeRecords[record.modelName][record.id];
  }

  /** Saves all records atomically. */
  public async saveAll(): Promise<void> {
    const recordsToSave: Model[] = [];
    const updates = {};
    Object.keys(this._activeRecords).map(modelName => {
      Object.keys(this._activeRecords[modelName]).map(id => {
        const record = this._activeRecords[modelName][id];
        // Save all records other than embedded ones, which will be saved when the containing record is saved
        if (!record.embedded) {
          recordsToSave.push(record);
        }
      });
    });
    await this.saveRecords(recordsToSave);
  }

  /**
   * Saves a list of records atomically
   * @param records An array of records to save
   */
  public async saveRecords(records: Model[]): Promise<void> {
    const recordsToSave: Model[] = records.slice();
    const seenRecords: Model[] = records.slice();
    const updates = {};
    while (recordsToSave.length > 0) {
      const recordToSave: Model = recordsToSave[0]; // Could just shift here but typescript thinks it might be null if we do
      recordsToSave.shift();
      recordToSave._willSave();
      Object.assign(updates, recordToSave._pathsToSave());
      // Add atomically linked records to list of records to save
      recordToSave._atomicallyLinked.map(linkedRecord => {
        if (!seenRecords.includes(linkedRecord)) {
          recordsToSave.push(linkedRecord);
          seenRecords.push(linkedRecord);
          linkedRecord._willSave();
        }
      });
    }
    await this._updatePaths(updates);
    await Promise.all(seenRecords.map(async (savedRecord: Model) => {
      await savedRecord._didSave();
    }));
  }

  /**
   * Saves the record. Intended by be called from Model, rather than directly
   * Will also save records that are atomically linked
   * @param record The record to save
   */
  public async _save(record: Model): Promise<void> {
    await this.saveRecords([record]);
  }

  public newKey(path: string): string {
    if (this._useUUID) {
      switch (this._useUUID) {
        case 1:
          return v1();
        case 4:
          return v4();
        default:
          throw Error(`Unsupported UUID version requested ${this._useUUID}, valid versions are 1 and 4`);
      }
    } else {
      // Use the firebase generated key. See: https://firebase.google.com/docs/reference/js/firebase.database.Reference#push
      return this.database.ref(path).push().key as string;
    }
  }

  private async _updatePaths(updates: { [path: string]: any }): Promise<void> {
    log('performing firebase updates');
    log(updates);
    try {
      await this.database.ref('/').update(updates);
    } catch (error) {
      log(`Failed to save updates: ${JSON.stringify(updates)} ${error} ${error.stack}`);
      throw error;
    }
  }

  private storeActiveRecord(record: ModelPromise<Model>): void {
    const id: string = record.id;
    const modelName: string = record.modelName;
    log('going to store %s:%s', modelName, id);
    if (!(modelName in this._activeRecords)) {
      this._activeRecords[modelName] = {};
    }
    this._activeRecords[modelName][id] = record;
  }

  private retrieveActiveRecord<T extends Model>(recordClass: ModelClass<T>, id: string): ModelPromise<T> | undefined {
    const modelName = recordClass.modelName;
    if (this._activeRecords[modelName] !== undefined && this._activeRecords[modelName][id] !== undefined) {
      return this._activeRecords[modelName][id] as ModelPromise<T>;
    } else {
      return undefined;
    }
  }

}
